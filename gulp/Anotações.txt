
// Para usar o Gulp e o pacote gulp-sass precisamos requerir os pacotes, atribuindo-os à variáveis para uso posterior
const gulp = require('gulp');
const sass = require('gulp-sass');
const autoprefixer = require('gulp-autoprefixer');
const browserSync = require('browser-sync').create();

function compilaSass() {
    // Uma função do Gulp deve sempre conter um retorno com o que se espera que a função exerça, abaixo a função: 
    // Recebe um gulp src responsável por linkar quais arquivos devem ser tratados, logo após a função pipe, indica que a função sass craida na variável acima usará o pacote gulp-sass, e ao final a função pipe se encarrega através da função dest(destino/destribuição) de enviar o arquivo para o diretório solicitado.
    // O símbolo * antes da extensão indica à função compilaSass que todos os arquivos dentro do diretório que conterem a extensão scss devem ser compilados para css. Também podemos usar a mesma classificação para indicar um diretório, caso a pasta anterior a esta também contenha arquivos com extensão scss. 
    // Ex.: gulp.src('css/scss/**/*.scss')
    // O atributo {outputStyle: 'compressed'} indica que o arquivo dese ser minificado na saída
    return gulp.src('css/scss/*.scss').pipe(sass({ outputStyle: "compressed" })).pipe(autoprefixer({ cascade: false })).pipe(gulp.dest('css/'));
}

// Para ativar a função criada, esta deve ser inserida numa task/tarefa, com um nome de tarefa (sass), ao qual será usado pelo pacote gulp via cmd quando chamado. contendo como próximo argumento o nome da funcção criada (compilaSass)
gulp.task('sass', compilaSass);

// Para evitar linhas de código, podemos escrever uma função anônima já inclusa numa task. Obs.: Somente uma tarefa pode ser passada, para executar várias tarefas em uma única função, faça da forma padrão
// gulp.task('watch', function () {
//     gulp.watch('css/scss/*.scss', ['compilaSass']);
// });

// A função watch do gulp é responsável por ficar "/escutando", determinados diretórios ou arquivos, e na menor possibilidade de mudança, são executadas. Uma watch pode conter dentro de gulp.watch('') outras tasks, que podem ser executadas em série, ou paralelamente, quando ouverem mudanças em tais arquivos.Ex.: gulp.watch('css/scss/*.scss', gulp.series('tarefa1', 'tarefa2'))

function watch() {
    gulp.watch('css/scss/*.scss', compilaSass);
};

// Uma tarefa Default é a tarefa Padrão que é chamada via bash através do comando gulp, esta pode conter somente a chamda para a task padrão, como ter outras tasks após ela. A mesma possui dois parâmetros "series, parallel" que podem ser usadas para determinar o fluxo que as tarefas serão aplicadas, como em série, onde as tarefas são executadas uma após a outra, ou todas ao mesmo tempo "paralelamente"
// gulp.task('default', watch)

function browser() {
    browserSync.init({
        server: {
            baseDir: "./"
        }
    });
};

gulp.task('browserSync', browser);
gulp.task('default', gulp.parallel('watch', 'browserSync'));



# ----------------------------------- HTML ----------------------------------- #
Para atualizar o Html automaticamente não podemos inserir mais um elemento na função Watch, como neste exemplo: 
function watch() {
    gulp.watch('css/scss/*.scss', compilaSass);
    gulp.watch('*.html', browserSync);
};

pois a função Watch não permite esse argumento para o BrowserSync, sendo necessário o uso da função .on('change'), que fará uma ação quando o elemento em watch for alterado: 

function watch() {
    gulp.watch('css/scss/*.scss', compilaSass);
    gulp.watch('*.html').on('change', browserSync.reload);
};

O método reload (proprietário da função BrowserSync, é responsável por carregar a página, quando alterada).

# ---------------------------------------------------------------------------- #
Também podemos alterar a função wacth para "escuta" outras extensões do diretório: 

function watch() {
    gulp.watch('css/scss/*.scss', compilaSass);
    gulp.watch('*.html').on('change', browserSync.reload);
};